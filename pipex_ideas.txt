SIGPIPE :
only send when the first cmd tries to WRITE in the pipe but the second has finished already 
	--> yes | echo yo #yes write to stdout
	--> sleep 10 | echo yo #sleep doesnot write to the pipe
These commands are interesting :
	--> top > /dev/null 2>&1 | sleep 1
	--> top | sleep 1
the first one is not stopped after sleep has returned : it does not write to the pipe.
the second one writes in the pipe : it is stopped after 1 sec. 

MULTIPIPING vs MAX FD :
1024 fd opened max
on my pipex : 2 fd for infile outfile + (nb_pipes = nb_cmds -1). A pipe requieres 2 fd.
so, if > 510 cmds, error when opening the 1024 fd : too many files opened.
This behaviour is not acceptable. It should be done only using 2 pipes so 4 fd. 
however I dont know how since the pipes must be and stay opened during the whole execution ie :
	--> < infile cat | cat | cat | cat | cat > /dev/stdout
	--> << LIM cat | cat | cat | cat | cat > /dev/stdout
	--> yes |Â cat | cat | cat | cat 
above 4 pipes are needed. last one is most obvious : it keeps on writing ys on stdout so all of the pipes are opened. 

Dhubleur le gere dans son minishell : https://github.com/dhubleur-42-projects/minishell/tree/a62c8f391d53656e234568b5bba311ab15a614da
